// 05_Class.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

// 클래스
// 객체를 정의하기 위해 작성하는 코드
// 클래스는 행동과 속성을 포함한다. 

class CObject
{
	// 접근제한 지정자 
	// 멤버의 접근 속성을 지정하는 것
	// pulic, protected, private

	//				외부 공개		파생 클래스 공개		내부공개
	// public		O				O					O
	// protected	X				O					O
	// private		X				X					O

public: 
	// 생성자
	// 객체가 생성될 때, 무언가를 하고 싶은 일이 있거나 객체를 초기화하고 싶을 때 호출되는 함수이다.
	// 
	// 생성자의 원형은 조금 특수한 함수로 반환 값이 존재하지 않는다. 사실상 생성자의 리턴 값은 void이다.
	// 그리고 생성자의 함수명은 클래스와 동일한 이름을 사용한다.

	// 객체를 생성할 때, 인자로 아무것도 넘겨주지 않는 생성자를 기본 생성자라고 한다.
	// 기본 생성자는 다음과 같은 구성으로 이루어져 있다.
	CObject()
		// 객체
		: mData(0)
		, mText("")
	{

	}

	// 인자 생성자
	// 인자를 전달받는 생성자 
	// 생성자의 오버로딩된 형태입니다
	// 모든 매개변수가 디폴트 인자로 선언되어 있을 경우, 
	// 컴파일러는 기본 생성자와 함수 형태가 같아 중복선언으로 받아 들인다. 오버로딩된 함수 모두 적용되는 특징이다.
	CObject(int _Data)
		: mData(_Data)
	{

	}

	// 소멸자
	// 객체가 소멸될 경우, 호출되는 함수
	// 소멸자 호출 후, 메모리를 반환한다.
	// 소멸자를 정의하지 않으면 컴파일러가 알아서 생성해 준다.
	// 소멸자 호출될 경우, 객체 내 멤버 변수의 소멸자는 재귀적으로 호출된다.
	~CObject()
	{
		std::cout << "소멸자 호출!" << "\n";
	}

	int mData{0};
	std::string mText;

}; // 클래스는 작업구문으로 콘솔(;) 마쳐주셔요.

int main()
{
	// 스택에 객체를 생성하는 예시
	{
		// 스택에 객체 생성
		CObject NewObject;

		// 할당된 객체의 멤버에 접근하려면 도트 연산자(.)를 사용해야 한다.
		NewObject.mText; 

		// 스택에 할당된 객체의 경우,
		// 객체가 유효한 범위에 존재하지 않으면 할당된 메모리는 컴파일러에 의해 반환된다.
	} 

	// 힙 영역에 객체 생성하는 예시
	{
		// 힙 영엑에 객체를 할당하려면 new 연산자를 사용해야한다.
		CObject* NewObject = new CObject;

		// 사용이 끝난 객체는 명시적으로 delete 연산자를 사용하여 메모리를 반환해야 한다.
		// 먼저 delete를 선언하고, 그 뒤에 반환할 객체의 포인터를 넘겨준다.
		delete NewObject;

		// *NewObject = 5;
		// 
		// 반환되면 객체를 가리키고 있던 포인터는 해제된 메모리 영역을 가리키게 된다.
		// 해제된 메모리를 사용하면 읽기 접근 위반으로 프로그램은 crash가 된다.
		// 이 문제를 '댕글링 포인터(Dangling pointer) 참조' 라고 한다.
		// 
		// 이러한 문제를 방지하기 위해서 댕글링 포인터는 nullptr 로 초기화해야 하고,
		// 포인터를 사용하기 전, 포인터가 가리키는 대상이 nullptr 인지 검사해야 한다.
		NewObject = nullptr;
	}


    std::cout << "Hello World!\n";
}